// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommonData.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "CommonData.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - CommonDataRoot

@implementation CommonDataRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[StatRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - CommonDataRoot_FileDescriptor

static GPBFileDescriptor *CommonDataRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum APP_SMS_PURPOSE

GPBEnumDescriptor *APP_SMS_PURPOSE_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SmsDefault\000AspLogin\000PhoneChange\000";
    static const int32_t values[] = {
        APP_SMS_PURPOSE_SmsDefault,
        APP_SMS_PURPOSE_AspLogin,
        APP_SMS_PURPOSE_PhoneChange,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(APP_SMS_PURPOSE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:APP_SMS_PURPOSE_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL APP_SMS_PURPOSE_IsValidValue(int32_t value__) {
  switch (value__) {
    case APP_SMS_PURPOSE_SmsDefault:
    case APP_SMS_PURPOSE_AspLogin:
    case APP_SMS_PURPOSE_PhoneChange:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SNS_TYPE

GPBEnumDescriptor *SNS_TYPE_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StUnknow\000StWechat\000StQq\000StWeibo\000StWxgz\000";
    static const int32_t values[] = {
        SNS_TYPE_StUnknow,
        SNS_TYPE_StWechat,
        SNS_TYPE_StQq,
        SNS_TYPE_StWeibo,
        SNS_TYPE_StWxgz,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SNS_TYPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SNS_TYPE_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SNS_TYPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case SNS_TYPE_StUnknow:
    case SNS_TYPE_StWechat:
    case SNS_TYPE_StQq:
    case SNS_TYPE_StWeibo:
    case SNS_TYPE_StWxgz:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SEX_TYPE

GPBEnumDescriptor *SEX_TYPE_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SexDefault\000StMan\000StWoman\000";
    static const int32_t values[] = {
        SEX_TYPE_SexDefault,
        SEX_TYPE_StMan,
        SEX_TYPE_StWoman,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SEX_TYPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SEX_TYPE_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SEX_TYPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case SEX_TYPE_SexDefault:
    case SEX_TYPE_StMan:
    case SEX_TYPE_StWoman:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum IMG_FORMAT

GPBEnumDescriptor *IMG_FORMAT_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ImgDefault\000ImgUnknow\000ImgJpeg\000ImgPng\000ImgW"
        "ebp\000";
    static const int32_t values[] = {
        IMG_FORMAT_ImgDefault,
        IMG_FORMAT_ImgUnknow,
        IMG_FORMAT_ImgJpeg,
        IMG_FORMAT_ImgPng,
        IMG_FORMAT_ImgWebp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(IMG_FORMAT)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:IMG_FORMAT_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL IMG_FORMAT_IsValidValue(int32_t value__) {
  switch (value__) {
    case IMG_FORMAT_ImgDefault:
    case IMG_FORMAT_ImgUnknow:
    case IMG_FORMAT_ImgJpeg:
    case IMG_FORMAT_ImgPng:
    case IMG_FORMAT_ImgWebp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AD_TYPE

GPBEnumDescriptor *AD_TYPE_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "AdDefault\000Splash\000HomePageBanner\000";
    static const int32_t values[] = {
        AD_TYPE_AdDefault,
        AD_TYPE_Splash,
        AD_TYPE_HomePageBanner,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AD_TYPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AD_TYPE_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AD_TYPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case AD_TYPE_AdDefault:
    case AD_TYPE_Splash:
    case AD_TYPE_HomePageBanner:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PayType

GPBEnumDescriptor *PayType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "DefaultPay\000AliZfb\000WxGz\000WxApp\000PosPay\000Cash"
        "\000Account\000WxQrcode\000WxSaas\000AliSaas\000PreFee\000"
        "Insure\000RebatePreFee\000AliH5Zfb\000BaofooAliap"
        "p\000BaofooWxgz\000BaofooWxapp\000BaofooWapAli\000Ba"
        "ofooWapWx\000YingsehngbaoAliH5\000Yingsehngbao"
        "WxgzH5\000PosWx\000PosZfb\000PosChuxu\000PosQq\000PosXi"
        "nyong\000AliZfbRefunnd\000WxGzRefund\000WxAppRefu"
        "nd\000AccountRefund\000TgRefund\000CashRefund\000";
    static const int32_t values[] = {
        PayType_DefaultPay,
        PayType_AliZfb,
        PayType_WxGz,
        PayType_WxApp,
        PayType_PosPay,
        PayType_Cash,
        PayType_Account,
        PayType_WxQrcode,
        PayType_WxSaas,
        PayType_AliSaas,
        PayType_PreFee,
        PayType_Insure,
        PayType_RebatePreFee,
        PayType_AliH5Zfb,
        PayType_BaofooAliapp,
        PayType_BaofooWxgz,
        PayType_BaofooWxapp,
        PayType_BaofooWapAli,
        PayType_BaofooWapWx,
        PayType_YingsehngbaoAliH5,
        PayType_YingsehngbaoWxgzH5,
        PayType_PosWx,
        PayType_PosZfb,
        PayType_PosChuxu,
        PayType_PosQq,
        PayType_PosXinyong,
        PayType_AliZfbRefunnd,
        PayType_WxGzRefund,
        PayType_WxAppRefund,
        PayType_AccountRefund,
        PayType_TgRefund,
        PayType_CashRefund,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PayType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PayType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PayType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PayType_DefaultPay:
    case PayType_AliZfb:
    case PayType_WxGz:
    case PayType_WxApp:
    case PayType_PosPay:
    case PayType_Cash:
    case PayType_Account:
    case PayType_WxQrcode:
    case PayType_WxSaas:
    case PayType_AliSaas:
    case PayType_PreFee:
    case PayType_Insure:
    case PayType_RebatePreFee:
    case PayType_AliH5Zfb:
    case PayType_BaofooAliapp:
    case PayType_BaofooWxgz:
    case PayType_BaofooWxapp:
    case PayType_BaofooWapAli:
    case PayType_BaofooWapWx:
    case PayType_YingsehngbaoAliH5:
    case PayType_YingsehngbaoWxgzH5:
    case PayType_PosWx:
    case PayType_PosZfb:
    case PayType_PosChuxu:
    case PayType_PosQq:
    case PayType_PosXinyong:
    case PayType_AliZfbRefunnd:
    case PayType_WxGzRefund:
    case PayType_WxAppRefund:
    case PayType_AccountRefund:
    case PayType_TgRefund:
    case PayType_CashRefund:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OrderPayStatus

GPBEnumDescriptor *OrderPayStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "PayNot\000Pay\000PayPart\000RefundProcess\000RefundF"
        "inish\000Abnormal\000";
    static const int32_t values[] = {
        OrderPayStatus_PayNot,
        OrderPayStatus_Pay,
        OrderPayStatus_PayPart,
        OrderPayStatus_RefundProcess,
        OrderPayStatus_RefundFinish,
        OrderPayStatus_Abnormal,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OrderPayStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OrderPayStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OrderPayStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case OrderPayStatus_PayNot:
    case OrderPayStatus_Pay:
    case OrderPayStatus_PayPart:
    case OrderPayStatus_RefundProcess:
    case OrderPayStatus_RefundFinish:
    case OrderPayStatus_Abnormal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OrderStatus

GPBEnumDescriptor *OrderStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "WaitPayPrefee\000WaitAssign\000WaitService\000Ser"
        "viceIng\000ServiceComplete\000WaitAppraise\000Ord"
        "erComplete\000Cancel\000";
    static const int32_t values[] = {
        OrderStatus_WaitPayPrefee,
        OrderStatus_WaitAssign,
        OrderStatus_WaitService,
        OrderStatus_ServiceIng,
        OrderStatus_ServiceComplete,
        OrderStatus_WaitAppraise,
        OrderStatus_OrderComplete,
        OrderStatus_Cancel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OrderStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OrderStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OrderStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case OrderStatus_WaitPayPrefee:
    case OrderStatus_WaitAssign:
    case OrderStatus_WaitService:
    case OrderStatus_ServiceIng:
    case OrderStatus_ServiceComplete:
    case OrderStatus_WaitAppraise:
    case OrderStatus_OrderComplete:
    case OrderStatus_Cancel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PayBusiType

GPBEnumDescriptor *PayBusiType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "DoNotUse\000RechargeD\000RechargeR\000PayPreamoun"
        "t\000PaySettlement\000PayOrder\000PayOrderExtra\000P"
        "ayInsure\000PayApply\000PayExtra\000PaySettlement"
        "Close\000PayOrderbatchsettle\000RefundExtra\000Re"
        "fundPrepay\000RefundSettlementClose\000RefundP"
        "repayCancel\000";
    static const int32_t values[] = {
        PayBusiType_DoNotUse,
        PayBusiType_RechargeD,
        PayBusiType_RechargeR,
        PayBusiType_PayPreamount,
        PayBusiType_PaySettlement,
        PayBusiType_PayOrder,
        PayBusiType_PayOrderExtra,
        PayBusiType_PayInsure,
        PayBusiType_PayApply,
        PayBusiType_PayExtra,
        PayBusiType_PaySettlementClose,
        PayBusiType_PayOrderbatchsettle,
        PayBusiType_RefundExtra,
        PayBusiType_RefundPrepay,
        PayBusiType_RefundSettlementClose,
        PayBusiType_RefundPrepayCancel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PayBusiType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PayBusiType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PayBusiType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PayBusiType_DoNotUse:
    case PayBusiType_RechargeD:
    case PayBusiType_RechargeR:
    case PayBusiType_PayPreamount:
    case PayBusiType_PaySettlement:
    case PayBusiType_PayOrder:
    case PayBusiType_PayOrderExtra:
    case PayBusiType_PayInsure:
    case PayBusiType_PayApply:
    case PayBusiType_PayExtra:
    case PayBusiType_PaySettlementClose:
    case PayBusiType_PayOrderbatchsettle:
    case PayBusiType_RefundExtra:
    case PayBusiType_RefundPrepay:
    case PayBusiType_RefundSettlementClose:
    case PayBusiType_RefundPrepayCancel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum InsureOrderStatus

GPBEnumDescriptor *InsureOrderStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "InsureWaitReceive\000InsureWaitPay\000InsureWa"
        "itAssign\000InsureWaitService\000InsureService"
        "Ing\000InsureWaitSettle\000InsureWaitAppraise\000"
        "InsureOrderComplete\000InsureCancel\000";
    static const int32_t values[] = {
        InsureOrderStatus_InsureWaitReceive,
        InsureOrderStatus_InsureWaitPay,
        InsureOrderStatus_InsureWaitAssign,
        InsureOrderStatus_InsureWaitService,
        InsureOrderStatus_InsureServiceIng,
        InsureOrderStatus_InsureWaitSettle,
        InsureOrderStatus_InsureWaitAppraise,
        InsureOrderStatus_InsureOrderComplete,
        InsureOrderStatus_InsureCancel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(InsureOrderStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:InsureOrderStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL InsureOrderStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case InsureOrderStatus_InsureWaitReceive:
    case InsureOrderStatus_InsureWaitPay:
    case InsureOrderStatus_InsureWaitAssign:
    case InsureOrderStatus_InsureWaitService:
    case InsureOrderStatus_InsureServiceIng:
    case InsureOrderStatus_InsureWaitSettle:
    case InsureOrderStatus_InsureWaitAppraise:
    case InsureOrderStatus_InsureOrderComplete:
    case InsureOrderStatus_InsureCancel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OrderButton

GPBEnumDescriptor *OrderButton_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "CancelOrder\000Jiedan\000Teach\000UpdateOrder\000Sen"
        "dCert\000UpdateKins\000StartService\000EndService"
        "\000Subsidy\000AgainOrder\000ServiceConfirm\000Apply"
        "EndService\000AssignHs\000UpdateHs\000CheckTend\000T"
        "endManage\000VisitRecord\000SelfAssess\000AssignT"
        "each\000TransferOrder\000UpdateHgTeach\000TeachRe"
        "cord\000";
    static const int32_t values[] = {
        OrderButton_CancelOrder,
        OrderButton_Jiedan,
        OrderButton_Teach,
        OrderButton_UpdateOrder,
        OrderButton_SendCert,
        OrderButton_UpdateKins,
        OrderButton_StartService,
        OrderButton_EndService,
        OrderButton_Subsidy,
        OrderButton_AgainOrder,
        OrderButton_ServiceConfirm,
        OrderButton_ApplyEndService,
        OrderButton_AssignHs,
        OrderButton_UpdateHs,
        OrderButton_CheckTend,
        OrderButton_TendManage,
        OrderButton_VisitRecord,
        OrderButton_SelfAssess,
        OrderButton_AssignTeach,
        OrderButton_TransferOrder,
        OrderButton_UpdateHgTeach,
        OrderButton_TeachRecord,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OrderButton)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OrderButton_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OrderButton_IsValidValue(int32_t value__) {
  switch (value__) {
    case OrderButton_CancelOrder:
    case OrderButton_Jiedan:
    case OrderButton_Teach:
    case OrderButton_UpdateOrder:
    case OrderButton_SendCert:
    case OrderButton_UpdateKins:
    case OrderButton_StartService:
    case OrderButton_EndService:
    case OrderButton_Subsidy:
    case OrderButton_AgainOrder:
    case OrderButton_ServiceConfirm:
    case OrderButton_ApplyEndService:
    case OrderButton_AssignHs:
    case OrderButton_UpdateHs:
    case OrderButton_CheckTend:
    case OrderButton_TendManage:
    case OrderButton_VisitRecord:
    case OrderButton_SelfAssess:
    case OrderButton_AssignTeach:
    case OrderButton_TransferOrder:
    case OrderButton_UpdateHgTeach:
    case OrderButton_TeachRecord:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - IMG_POINT

@implementation IMG_POINT

@dynamic x;
@dynamic y;

typedef struct IMG_POINT__storage_ {
  uint32_t _has_storage_[1];
  double x;
  double y;
} IMG_POINT__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = IMG_POINT_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMG_POINT__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = IMG_POINT_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMG_POINT__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMG_POINT class]
                                     rootClass:[CommonDataRoot class]
                                          file:CommonDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMG_POINT__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ImgInfo

@implementation ImgInfo

@dynamic imgId;
@dynamic imgurl;
@dynamic thumbImgurl;
@dynamic height;
@dynamic width;
@dynamic bgcolor;
@dynamic imgtype;
@dynamic hasCenter, center;
@dynamic suffix;
@dynamic type;

typedef struct ImgInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t height;
  uint32_t width;
  uint32_t bgcolor;
  IMG_FORMAT imgtype;
  NSString *imgurl;
  NSString *thumbImgurl;
  IMG_POINT *center;
  NSString *suffix;
  NSString *type;
  uint64_t imgId;
} ImgInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imgId",
        .dataTypeSpecific.className = NULL,
        .number = ImgInfo_FieldNumber_ImgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ImgInfo__storage_, imgId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "imgurl",
        .dataTypeSpecific.className = NULL,
        .number = ImgInfo_FieldNumber_Imgurl,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ImgInfo__storage_, imgurl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thumbImgurl",
        .dataTypeSpecific.className = NULL,
        .number = ImgInfo_FieldNumber_ThumbImgurl,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ImgInfo__storage_, thumbImgurl),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = ImgInfo_FieldNumber_Height,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ImgInfo__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = ImgInfo_FieldNumber_Width,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ImgInfo__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bgcolor",
        .dataTypeSpecific.className = NULL,
        .number = ImgInfo_FieldNumber_Bgcolor,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ImgInfo__storage_, bgcolor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgtype",
        .dataTypeSpecific.enumDescFunc = IMG_FORMAT_EnumDescriptor,
        .number = ImgInfo_FieldNumber_Imgtype,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ImgInfo__storage_, imgtype),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "center",
        .dataTypeSpecific.className = GPBStringifySymbol(IMG_POINT),
        .number = ImgInfo_FieldNumber_Center,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ImgInfo__storage_, center),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "suffix",
        .dataTypeSpecific.className = NULL,
        .number = ImgInfo_FieldNumber_Suffix,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ImgInfo__storage_, suffix),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ImgInfo_FieldNumber_Type,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ImgInfo__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ImgInfo class]
                                     rootClass:[CommonDataRoot class]
                                          file:CommonDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ImgInfo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\005\000\003\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ImgInfo_Imgtype_RawValue(ImgInfo *message) {
  GPBDescriptor *descriptor = [ImgInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ImgInfo_FieldNumber_Imgtype];
  return GPBGetMessageInt32Field(message, field);
}

void SetImgInfo_Imgtype_RawValue(ImgInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [ImgInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ImgInfo_FieldNumber_Imgtype];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - SplashItem

@implementation SplashItem

@dynamic id_p;
@dynamic hasImgInfo, imgInfo;
@dynamic startTimeCd;
@dynamic endTimeCd;
@dynamic onlyOneTime;

typedef struct SplashItem__storage_ {
  uint32_t _has_storage_[1];
  uint32_t id_p;
  ImgInfo *imgInfo;
  uint64_t startTimeCd;
  uint64_t endTimeCd;
} SplashItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = SplashItem_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SplashItem__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(ImgInfo),
        .number = SplashItem_FieldNumber_ImgInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SplashItem__storage_, imgInfo),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "startTimeCd",
        .dataTypeSpecific.className = NULL,
        .number = SplashItem_FieldNumber_StartTimeCd,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SplashItem__storage_, startTimeCd),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "endTimeCd",
        .dataTypeSpecific.className = NULL,
        .number = SplashItem_FieldNumber_EndTimeCd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SplashItem__storage_, endTimeCd),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "onlyOneTime",
        .dataTypeSpecific.className = NULL,
        .number = SplashItem_FieldNumber_OnlyOneTime,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SplashItem class]
                                     rootClass:[CommonDataRoot class]
                                          file:CommonDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SplashItem__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\007\000\003\nA\000\004\010A\000\005\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADItem

@implementation ADItem

@dynamic id_p;
@dynamic type;
@dynamic index;
@dynamic hasImgInfo, imgInfo;
@dynamic jumpto;
@dynamic startTimeCd;
@dynamic endTimeCd;
@dynamic onlyOneTime;
@dynamic hasImgInfoNew, imgInfoNew;

typedef struct ADItem__storage_ {
  uint32_t _has_storage_[1];
  uint32_t id_p;
  AD_TYPE type;
  uint32_t index;
  ImgInfo *imgInfo;
  NSString *jumpto;
  ImgInfo *imgInfoNew;
  uint64_t startTimeCd;
  uint64_t endTimeCd;
} ADItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ADItem_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADItem__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = AD_TYPE_EnumDescriptor,
        .number = ADItem_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADItem__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = ADItem_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADItem__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(ImgInfo),
        .number = ADItem_FieldNumber_ImgInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADItem__storage_, imgInfo),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "jumpto",
        .dataTypeSpecific.className = NULL,
        .number = ADItem_FieldNumber_Jumpto,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ADItem__storage_, jumpto),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startTimeCd",
        .dataTypeSpecific.className = NULL,
        .number = ADItem_FieldNumber_StartTimeCd,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ADItem__storage_, startTimeCd),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "endTimeCd",
        .dataTypeSpecific.className = NULL,
        .number = ADItem_FieldNumber_EndTimeCd,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ADItem__storage_, endTimeCd),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "onlyOneTime",
        .dataTypeSpecific.className = NULL,
        .number = ADItem_FieldNumber_OnlyOneTime,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "imgInfoNew",
        .dataTypeSpecific.className = GPBStringifySymbol(ImgInfo),
        .number = ADItem_FieldNumber_ImgInfoNew,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ADItem__storage_, imgInfoNew),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADItem class]
                                     rootClass:[CommonDataRoot class]
                                          file:CommonDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADItem__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\004\007\000\006\nA\000\007\010A\000\010\013\000\t\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADItem_Type_RawValue(ADItem *message) {
  GPBDescriptor *descriptor = [ADItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADItem_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetADItem_Type_RawValue(ADItem *message, int32_t value) {
  GPBDescriptor *descriptor = [ADItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADItem_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - SettingItem

@implementation SettingItem

@dynamic k;
@dynamic v;

typedef struct SettingItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *k;
  NSData *v;
} SettingItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "k",
        .dataTypeSpecific.className = NULL,
        .number = SettingItem_FieldNumber_K,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SettingItem__storage_, k),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "v",
        .dataTypeSpecific.className = NULL,
        .number = SettingItem_FieldNumber_V,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SettingItem__storage_, v),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SettingItem class]
                                     rootClass:[CommonDataRoot class]
                                          file:CommonDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SettingItem__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StatReportItem

@implementation StatReportItem

@dynamic type;
@dynamic version;
@dynamic data_p;

typedef struct StatReportItem__storage_ {
  uint32_t _has_storage_[1];
  STAT_TYPE type;
  uint32_t version;
  NSData *data_p;
} StatReportItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = STAT_TYPE_EnumDescriptor,
        .number = StatReportItem_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StatReportItem__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = StatReportItem_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StatReportItem__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = StatReportItem_FieldNumber_Data_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StatReportItem__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StatReportItem class]
                                     rootClass:[CommonDataRoot class]
                                          file:CommonDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StatReportItem__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t StatReportItem_Type_RawValue(StatReportItem *message) {
  GPBDescriptor *descriptor = [StatReportItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StatReportItem_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetStatReportItem_Type_RawValue(StatReportItem *message, int32_t value) {
  GPBDescriptor *descriptor = [StatReportItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StatReportItem_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
