// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Lbs.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Lbs.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - LbsRoot

@implementation LbsRoot

@end

#pragma mark - LbsRoot_FileDescriptor

static GPBFileDescriptor *LbsRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - LbsLocation

@implementation LbsLocation

@dynamic latitude;
@dynamic longitude;
@dynamic altitude;
@dynamic accuracy;
@dynamic bearing;
@dynamic speed;
@dynamic time;
@dynamic locationId;
@dynamic adCode;

typedef struct LbsLocation__storage_ {
  uint32_t _has_storage_[1];
  uint32_t altitude;
  uint32_t accuracy;
  uint32_t bearing;
  uint32_t speed;
  uint32_t adCode;
  double latitude;
  double longitude;
  uint64_t time;
  uint64_t locationId;
} LbsLocation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = LbsLocation_FieldNumber_Latitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LbsLocation__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = LbsLocation_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LbsLocation__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "altitude",
        .dataTypeSpecific.className = NULL,
        .number = LbsLocation_FieldNumber_Altitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LbsLocation__storage_, altitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "accuracy",
        .dataTypeSpecific.className = NULL,
        .number = LbsLocation_FieldNumber_Accuracy,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LbsLocation__storage_, accuracy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bearing",
        .dataTypeSpecific.className = NULL,
        .number = LbsLocation_FieldNumber_Bearing,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LbsLocation__storage_, bearing),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "speed",
        .dataTypeSpecific.className = NULL,
        .number = LbsLocation_FieldNumber_Speed,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LbsLocation__storage_, speed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = LbsLocation_FieldNumber_Time,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LbsLocation__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "locationId",
        .dataTypeSpecific.className = NULL,
        .number = LbsLocation_FieldNumber_LocationId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LbsLocation__storage_, locationId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "adCode",
        .dataTypeSpecific.className = NULL,
        .number = LbsLocation_FieldNumber_AdCode,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LbsLocation__storage_, adCode),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LbsLocation class]
                                     rootClass:[LbsRoot class]
                                          file:LbsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LbsLocation__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\010\n\000\t\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LbsCell

@implementation LbsCell

@dynamic mcc;
@dynamic mnc;
@dynamic lac;
@dynamic cellId;
@dynamic rssi;

typedef struct LbsCell__storage_ {
  uint32_t _has_storage_[1];
  uint32_t mcc;
  uint32_t mnc;
  uint32_t lac;
  uint32_t cellId;
  uint32_t rssi;
} LbsCell__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mcc",
        .dataTypeSpecific.className = NULL,
        .number = LbsCell_FieldNumber_Mcc,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LbsCell__storage_, mcc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "mnc",
        .dataTypeSpecific.className = NULL,
        .number = LbsCell_FieldNumber_Mnc,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LbsCell__storage_, mnc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lac",
        .dataTypeSpecific.className = NULL,
        .number = LbsCell_FieldNumber_Lac,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LbsCell__storage_, lac),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cellId",
        .dataTypeSpecific.className = NULL,
        .number = LbsCell_FieldNumber_CellId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LbsCell__storage_, cellId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rssi",
        .dataTypeSpecific.className = NULL,
        .number = LbsCell_FieldNumber_Rssi,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LbsCell__storage_, rssi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LbsCell class]
                                     rootClass:[LbsRoot class]
                                          file:LbsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LbsCell__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LbsWifiMac

@implementation LbsWifiMac

@dynamic mac;
@dynamic rssi;

typedef struct LbsWifiMac__storage_ {
  uint32_t _has_storage_[1];
  uint32_t rssi;
  NSString *mac;
} LbsWifiMac__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mac",
        .dataTypeSpecific.className = NULL,
        .number = LbsWifiMac_FieldNumber_Mac,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LbsWifiMac__storage_, mac),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rssi",
        .dataTypeSpecific.className = NULL,
        .number = LbsWifiMac_FieldNumber_Rssi,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LbsWifiMac__storage_, rssi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LbsWifiMac class]
                                     rootClass:[LbsRoot class]
                                          file:LbsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LbsWifiMac__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddrInfo

@implementation AddrInfo

@dynamic province;
@dynamic city;
@dynamic district;
@dynamic streetName;
@dynamic streetNum;
@dynamic addrStr;

typedef struct AddrInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *province;
  NSString *city;
  NSString *district;
  NSString *streetName;
  NSString *streetNum;
  NSString *addrStr;
} AddrInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "province",
        .dataTypeSpecific.className = NULL,
        .number = AddrInfo_FieldNumber_Province,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddrInfo__storage_, province),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "city",
        .dataTypeSpecific.className = NULL,
        .number = AddrInfo_FieldNumber_City,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddrInfo__storage_, city),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "district",
        .dataTypeSpecific.className = NULL,
        .number = AddrInfo_FieldNumber_District,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddrInfo__storage_, district),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streetName",
        .dataTypeSpecific.className = NULL,
        .number = AddrInfo_FieldNumber_StreetName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddrInfo__storage_, streetName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streetNum",
        .dataTypeSpecific.className = NULL,
        .number = AddrInfo_FieldNumber_StreetNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AddrInfo__storage_, streetNum),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addrStr",
        .dataTypeSpecific.className = NULL,
        .number = AddrInfo_FieldNumber_AddrStr,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AddrInfo__storage_, addrStr),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddrInfo class]
                                     rootClass:[LbsRoot class]
                                          file:LbsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddrInfo__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\004\n\000\005\t\000\006\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LbsData

@implementation LbsData

@dynamic hasLocation, location;
@dynamic hasAddrInfo, addrInfo;
@dynamic cellsArray, cellsArray_Count;
@dynamic wifisArray, wifisArray_Count;

typedef struct LbsData__storage_ {
  uint32_t _has_storage_[1];
  LbsLocation *location;
  AddrInfo *addrInfo;
  NSMutableArray *cellsArray;
  NSMutableArray *wifisArray;
} LbsData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "location",
        .dataTypeSpecific.className = GPBStringifySymbol(LbsLocation),
        .number = LbsData_FieldNumber_Location,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LbsData__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addrInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(AddrInfo),
        .number = LbsData_FieldNumber_AddrInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LbsData__storage_, addrInfo),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cellsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LbsCell),
        .number = LbsData_FieldNumber_CellsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LbsData__storage_, cellsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wifisArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LbsWifiMac),
        .number = LbsData_FieldNumber_WifisArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LbsData__storage_, wifisArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LbsData class]
                                     rootClass:[LbsRoot class]
                                          file:LbsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LbsData__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
